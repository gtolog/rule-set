name: Resolve

on:
  push:
    branches: [ main ]
  workflow_dispatch:
  schedule:
    - cron: '0 12 * * *'

jobs:
  resolve-hosts-and-save-ipcidr:
    runs-on: ubuntu-latest

    env:
      RESOLVER1: "223.5.5.5"
      RESOLVER2: "119.29.29.29"
      INPUT: "DoH-elf.list"
      OUTPUT: "ipcidr.txt"
      
    steps:
      - uses: actions/checkout@v3  # Checkout the repo

      - name: Ensure dig is installed
        run: |
          sudo apt-get update
          sudo apt-get install -y dnsutils

      - name: Check for the input file
        run: |
          if [ ! -f "$INPUT" ]; then
            echo "Input file $INPUT not found, please check if it's committed to the repository."
            exit 1
          fi

      - name: Extract hostnames, resolve IPs, and extract IP-CIDRs
        run: |
          echo "Resolved IPs and Extracted IP-CIDRs:"
          
          # Create an empty file for IP-CIDRs and resolved IPs
          > $OUTPUT
          
          # Function to resolve CNAMEs to IPs recursively, avoiding loops
          resolve_cname() {
            local domain="$1"
            local resolved_ips=""
            local cname=""
            
            # Check if we've already resolved this domain to avoid infinite loops
            if [[ " ${resolved_domains[@]} " =~ " ${domain} " ]]; then
              echo "Already resolved: $domain"
              return
            fi
            resolved_domains+=("$domain")  # Track the domain we've resolved

            echo "Resolving domain: $domain"
            # Attempt to resolve the domain to an IP address
            resolved_ips=$(dig +short "$domain" | grep -v "^\;")  # Exclude comments
            if [[ -z "$resolved_ips" ]]; then
              # If no IPs found, check for CNAMEs
              cname=$(dig +short CNAME "$domain" | grep -v "^\;")
              if [[ -n "$cname" ]]; then
                echo "CNAME found for $domain -> $cname"
                resolved_ips=$(resolve_cname "$cname")  # Recursively resolve CNAME
              fi
            fi
            echo "Resolved IPs for $domain: $resolved_ips"
            echo "$resolved_ips"  # Return resolved IPs or CNAMEs
          }

          # Initialize an array to track resolved domains and avoid infinite loops
          resolved_domains=()

          # Process each line from the input file
          grep -E '^HOST,|^IP-CIDR,' $INPUT | while IFS=',' read -r type value other; do
            if [[ "$type" == "HOST" ]]; then
              # Try resolving the hostname with two resolvers from environment variables
              ips=""
              for resolver in "$RESOLVER1" "$RESOLVER2"; do
                # Get all available IPs for the domain
                ips=$(dig @"$resolver" +short "$value" | grep -v "^\;")
                if [[ -n "$ips" ]]; then
                  break
                fi
              done

              if [[ -n "$ips" ]]; then
                # For each resolved IP, check if it's a CNAME and resolve it further
                for ip in $ips; do
                  # If it's a CNAME (ends with a dot), resolve it further
                  if [[ "$ip" =~ \.$ ]]; then
                    resolved_ips=$(resolve_cname "$ip")
                    # Store each resolved IP
                    for resolved_ip in $resolved_ips; do
                      echo "$value -> $resolved_ip"
                      echo "$resolved_ip" >> $OUTPUT
                    done
                  else
                    echo "$value -> $ip"
                    echo "$ip" >> $OUTPUT
                  fi
                done
              else
                echo "$value -> No IP found"
              fi
            elif [[ "$type" == "IP-CIDR" ]]; then
              # Save IP-CIDR directly to the file
              echo "$value" >> $OUTPUT
              echo "Saved IP-CIDR: $value"
            fi
          done
          
          # Remove duplicates and sort the final list of IPs
          echo "Final IP-CIDR List (including resolved IPs):"
          sort -u $OUTPUT -o $OUTPUT  # Sort and remove duplicates in place
          cat $OUTPUT
